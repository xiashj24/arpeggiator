// poly track reuse most of the implementations for time-keeping from mono
// track, but renders the step differently

// note: maybe it makes sense to inherit from Track to create mono track and
// make track Abstract
#pragma once
#include "PolyArp/Track.h"

/*
  gate time -> note.length

  -> inside renderStep
  play mode
  octave range
  rhythm pattern (Euclidean like)

  *arp rate -> sequencer step rate
  *resync to master length: same as nono sequencer

  snap to grid?
  retrigger by new note?

*/

// Q: velocity strategty of MIDI notes generated by arpeggio?
// fixed
// as recorded
// average of all held notes
// predefined pattern for each arp type
// integrate with global groove function
//

namespace Sequencer {
class Arpeggiator : public Track {
public:
  enum class ArpType {
    Rise,
    Fall,
    RiseFall,
    RiseNFall,
    FallRise,
    FallNRise,
    OddEven,
    EvenOdd,
    Random,
    Shuffle,  // random once
    Walk,     // (Arturia)
    RandomTwo,
    Chord,
    Manual,
    // Gacha,        // Pattern in Arturia
    // GoldenRatio,  // Arp of darkness?
  };

  enum Rhythm {
    // store rhythm patterns as 16 bit ints? or use a more straightforward data
    // structure?
    Dummy = 0,
  };

  Arpeggiator(int channel,
              const KeyboardState& keyboard,
              int length = STEP_SEQ_DEFAULT_LENGTH,
              Resolution unit = _8th,
              ArpType type = ArpType::Rise,  // TODO: change later
              float gate = DEFAULT_LENGTH,
              float octave = 1.f)
      : Track(channel, keyboard, length, unit),
        type_(type),
        gate_(gate),
        octave_(octave) {
    // register a callback to modify the track legnth when keyboardState
    // changes?
  }

private:
  ArpType type_;
  // Rhythm rhythm_;
  float gate_;                     // 0..200%
  [[maybe_unused]] float octave_;  // 0..4.0 (fractional)

  // length change according to keyboardRef
  // What should happen if length shrinks?

  // other ideas:
  // int stepOffset_; // try first
  // start by new note?

  // sync'd to clock: render precisely on grids should be fine
  int getStepRenderTick(int index) const override final {
    return index * getTicksPerStep();
  }

  void renderStep(int index) override final {
    int num_notes_pressed = keyboardRef.getNumNotesPressed();
    int seq_length = num_notes_pressed;

    

    auto note_stack = keyboardRef.getNoteStack();

    auto sorted_notes = note_stack;  // copy
    std::sort(sorted_notes.begin(), sorted_notes.end(),
              [](const juce::MidiMessage& lhs, const juce::MidiMessage& rhs) {
                return lhs.getNoteNumber() < rhs.getNoteNumber();
              });

    Note arp_note;
    arp_note.length = gate_;
    // TODO: other velocity settings than average: as played, last
    // arp_note.velocity = keyboardRef.getAverageVelocity();

    switch (type_) {
      case ArpType::Manual:
        arp_note.number =
            note_stack[static_cast<size_t>(index%num_notes_pressed)]
                .getNoteNumber();
        arp_note.velocity =
            note_stack[static_cast<size_t>(index%num_notes_pressed)]
                .getVelocity();
        seq_length = num_notes_pressed;
        break;

      case ArpType::Rise:
        // use sorted noteStack
        seq_length = num_notes_pressed;
        arp_note.number =
            sorted_notes[static_cast<size_t>(index % num_notes_pressed)]
                .getNoteNumber();
        arp_note.velocity =
            sorted_notes[static_cast<size_t>(index % num_notes_pressed)]
                .getVelocity();
        // problem: occasionally same notes play twice simultaneously

        break;

      case ArpType::Fall:
        // use sorted noteStack

        seq_length = num_notes_pressed;
        break;

      case ArpType::RiseFall:
        // use sorted noteStack

        seq_length = 2 * num_notes_pressed;
        break;

      case ArpType::RiseNFall:
        // use sorted noteStack

        seq_length = 2 * num_notes_pressed - 1;
        break;

      case ArpType::FallRise:
        // use sorted noteStack
        seq_length = 2 * num_notes_pressed;
        break;

      case ArpType::FallNRise:
        // use sorted noteStack
        seq_length = 2 * num_notes_pressed - 1;
        break;

      case ArpType::OddEven:
        seq_length = num_notes_pressed;

        break;

      case ArpType::EvenOdd:
        seq_length = num_notes_pressed;

        break;

      case ArpType::Random:
        seq_length = num_notes_pressed;

        break;

      case ArpType::Shuffle:
        seq_length = num_notes_pressed;

        break;

      case ArpType::Walk:
        seq_length = num_notes_pressed;

        break;

      case ArpType::RandomTwo:
        seq_length = num_notes_pressed * 2;

        break;

      case ArpType::Chord:
        seq_length = 1;  // any value will do?
        break;

      default:
        break;
    }

    DBG("index: " << index << " note: " << arp_note.number);

    setLengthDeferred(seq_length);

    renderNote(index, arp_note);
  }
};
}  // namespace Sequencer
